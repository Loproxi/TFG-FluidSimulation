// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateNextPositions
#pragma kernel UpdateSpatialHashingInfo
#pragma kernel SortSpatialHashingInfo
#pragma kernel UpdateSpatialHashingIndices
#pragma kernel ComputeDensity
#pragma kernel ComputePressure
#pragma kernel ComputeViscosity
#pragma kernel ApplyForcesAndCollisions

//Include Functions From another hlsl
#include "FluidComputeTools.hlsl" // WHY THS BREAKS

struct FluidParticleData
{
    float2 position; // 8
    float2 nextPosition; // 8
    float2 velocity; // 8
    float mass; // 4
    float density; // 4
    float nearDensity; // 4
};

static const int numOfThreads = 64;
static const uint MAX_UINT_VALUE = 4294967295;

//Buffer that will come back
RWStructuredBuffer<FluidParticleData> Particles;
RWStructuredBuffer<uint2> SpatialHashingInfo; // Vector x = particleIndex Vector Y = cellkey
RWStructuredBuffer<uint> SpatialHashingIndices;

float smoothingDensityRadius;
float collisionDamping;
float gasConstant;
float nearDensityConstant;
float restDensity;
float gravity;
float deltaTime;
float viscosity;
float4 bounds; // MINBOUNDS X, MINBOUNDS Y, MAXBOUNDS X,MAXBOUNDS Y
float particleScale;
int numOfParticles;
float volumeSmoothNearDensity1;
float volumeSmoothDensity2;
float volumeSmoothNearPressure1;
float volumeSmoothPressure2;
float volumeSmoothViscosity3;

//BITONIC SORT
int numEntries;
int groupWidth;
int groupHeight;
int stepIndex;

//EACH WORK GROUP HAS 64 THREADS INSIDE OF IT
[numthreads(numOfThreads, 1, 1)]
void UpdateNextPositions(uint3 groupID : SV_GroupID,uint groupIndex : SV_GroupIndex)
{  
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    
    //Create a deltaTime to predict
    float predictionDeltaTime = 1.0f / 120.0f;
    
    Particles[particleId].velocity += float2(0.0f, gravity * deltaTime);
    //Predict where the particle is going to be on the next frame
    Particles[particleId].nextPosition = Particles[particleId].position + Particles[particleId].velocity * predictionDeltaTime;

}

[numthreads(numOfThreads, 1, 1)]
void UpdateSpatialHashingInfo(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    
    //Restart All indices by setting all of them to the Max UINT value
    SpatialHashingIndices[particleId].x = MAX_UINT_VALUE;
    
    int2 cell = GetCellFromPosition(Particles[particleId].position, smoothingDensityRadius);
    uint key = GetKeyFromHashedCell(HashingCell(cell), numOfParticles);

    //Update the Info on the spatial hashing
    SpatialHashingInfo[particleId] = uint2(particleId, key);

}

[numthreads(128, 1, 1)]
void SortSpatialHashingInfo(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;

    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / (uint)2;
    uint indexRight = indexLeft + rightStepSize;

	// Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= (uint)numEntries) return;

    uint valueLeft = SpatialHashingInfo[indexLeft].y;
    uint valueRight = SpatialHashingInfo[indexRight].y;

	// Swap entries if value is descending
    if (valueLeft > valueRight)
    {
        uint2 temp = SpatialHashingInfo[indexLeft];
        SpatialHashingInfo[indexLeft] = SpatialHashingInfo[indexRight];
        SpatialHashingInfo[indexRight] = temp;
    }
}

[numthreads(numOfThreads, 1, 1)]
void UpdateSpatialHashingIndices(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    
    uint key = SpatialHashingInfo[particleId].y;
    uint beforeKey = MAX_UINT_VALUE;
    
    if ((particleId-1) >= 0)
    {
        beforeKey = SpatialHashingInfo[particleId - 1].y;
    }
    
    if(key != beforeKey || particleId == 0)
    {
        SpatialHashingIndices[key] = particleId;
    }
}

[numthreads(numOfThreads, 1, 1)]
void ComputeDensity(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    
    FluidParticleData particle = Particles[particleId];
    //Compute radius * radius to avoid computing square
    float radius2 = smoothingDensityRadius * smoothingDensityRadius;
    float density = 0.0f;
    float nearDens = 0.0f;
    const int nearCellsSize = 9;
    int2 nearCells[nearCellsSize];
    
    SelectSurroundingCells(particle.nextPosition, smoothingDensityRadius, nearCells);

    for (int i = 0; i < nearCellsSize; i++)
    {
        uint key = GetKeyFromHashedCell(HashingCell(nearCells[i]),numOfParticles);
        uint index = SpatialHashingIndices[key];
                        //POT ESTAR MALAMENT
        while (index < (uint)numOfParticles && SpatialHashingInfo[index].y == key)
        {

            uint neighbourIndex = SpatialHashingInfo[index].x;

            float2 particleToOther = Particles[neighbourIndex].nextPosition - Particles[particleId].nextPosition;
            float sqrDistFromCenterToNeighbour = dot(particleToOther, particleToOther);

            if (sqrDistFromCenterToNeighbour <= radius2)
            {
                float dist = sqrt(sqrDistFromCenterToNeighbour);
                float influence = Ver_2_SmoothDensityKernel(smoothingDensityRadius, dist,volumeSmoothDensity2);
                float nearInfluence = Ver_1_SmoothNearDensityKernel(smoothingDensityRadius, dist,volumeSmoothNearDensity1);
                
                density += Particles[particleId].mass * influence;
                nearDens += Particles[particleId].mass * nearInfluence;           
                
            }
            index++;
        }
    }
    density = max(density, 0.001f);
    nearDens = max(nearDens, 0.001f);
    
    Particles[particleId].density = density;
    Particles[particleId].nearDensity = nearDens;
}

[numthreads(numOfThreads, 1, 1)]
void ComputePressure(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    
    FluidParticleData particle = Particles[particleId];
    //Compute radius * radius to avoid computing square
    float radius2 = smoothingDensityRadius * smoothingDensityRadius;
    float2 pressure = float2(0.0f,0.0f);
    const int nearCellsSize = 9;
    int2 nearCells[nearCellsSize];
    
    SelectSurroundingCells(particle.nextPosition, smoothingDensityRadius, nearCells);

    for (int i = 0; i < nearCellsSize; i++)
    {
        uint key = GetKeyFromHashedCell(HashingCell(nearCells[i]), numOfParticles);
        uint index = SpatialHashingIndices[key];
                        //POT ESTAR MALAMENT
        while (index < (uint)numOfParticles && SpatialHashingInfo[index].y == key)
        {

            uint neighbourIndex = SpatialHashingInfo[index].x;

            if (particleId == neighbourIndex)
            {
                index++;
                continue;
            }
            
            float2 particleToOther = Particles[neighbourIndex].nextPosition - particle.nextPosition;
            float sqrDistFromCenterToNeighbour = dot(particleToOther, particleToOther);

            if (sqrDistFromCenterToNeighbour <= radius2)
            {

                
                float dist = sqrt(sqrDistFromCenterToNeighbour);
                float2 direction = dist > 0 ? particleToOther / dist : float2(0, 1);
                float slope = Derivative_Ver_2_SmoothDensityKernel(smoothingDensityRadius, dist, volumeSmoothPressure2);
                float nearSlope = Derivative_Ver_1_SmoothNearDensityKernel(smoothingDensityRadius, dist,volumeSmoothNearPressure1);
                float pressureBetweenParticles = (ConvertDensityIntoPressure(particle.density, restDensity, gasConstant) + ConvertDensityIntoPressure(Particles[neighbourIndex].density, restDensity, gasConstant)) * 0.5f;
                float nearPressureBetweenParticles = (ConvertNearDensityIntoPressure(particle.nearDensity, nearDensityConstant) + ConvertNearDensityIntoPressure(Particles[neighbourIndex].nearDensity, nearDensityConstant)) * 0.5f;
      
                pressure += particle.mass * direction * slope * pressureBetweenParticles / Particles[neighbourIndex].density;
                pressure += direction * nearSlope * nearPressureBetweenParticles / Particles[neighbourIndex].nearDensity;
                
            }
            index++;
        }
    }
    
    float2 pressureAcceleration = float2(0.0f,0.0f);

    pressureAcceleration = pressure / particle.density;

    Particles[particleId].velocity += pressureAcceleration * deltaTime;
}

[numthreads(numOfThreads, 1, 1)]
void ComputeViscosity(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    
    FluidParticleData particle = Particles[particleId];
    //Compute radius * radius to avoid computing square
    float radius2 = smoothingDensityRadius * smoothingDensityRadius;
    float2 _viscosity = float2(0.0f,0.0f);
    const int nearCellsSize = 9;
    int2 nearCells[nearCellsSize];
    
    SelectSurroundingCells(particle.nextPosition, smoothingDensityRadius, nearCells);

    for (int i = 0; i < nearCellsSize; i++)
    {
        uint key = GetKeyFromHashedCell(HashingCell(nearCells[i]), numOfParticles);
        uint index = SpatialHashingIndices[key];
                        //POT ESTAR MALAMENT
        while (index < (uint) numOfParticles && SpatialHashingInfo[index].y == key)
        {

            uint neighbourIndex = SpatialHashingInfo[index].x;
            
            if (particleId == neighbourIndex)
            {
                index++;
                continue;
            }

            float2 particleToOther = Particles[neighbourIndex].nextPosition - particle.nextPosition;
            float sqrDistFromCenterToNeighbour = dot(particleToOther, particleToOther);

            if (sqrDistFromCenterToNeighbour <= radius2)
            {
                float dist = sqrt(sqrDistFromCenterToNeighbour);
                float viscInfluence = Ver_3_SmoothDensityKernel(smoothingDensityRadius, dist,volumeSmoothViscosity3);

                _viscosity = particle.mass * (Particles[neighbourIndex].velocity - particle.velocity) / Particles[neighbourIndex].density;
                _viscosity *= viscInfluence;
            }
            index++;
        }
    }
    
    Particles[particleId].velocity += _viscosity * viscosity * deltaTime;
}

[numthreads(numOfThreads, 1, 1)]
void ApplyForcesAndCollisions(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint particleId = groupID.x * numOfThreads + groupIndex;
    
    if (particleId >= (uint) numOfParticles) return;
    //Apply Velocity to particles
    Particles[particleId].position += Particles[particleId].velocity * deltaTime;
    
    float2 particlePosition = Particles[particleId].position;
    float2 particleVelocity = Particles[particleId].velocity;

    float2 particleSize = float2(1.0f,1.0f) * particleScale;

    Particles[particleId].position = float2(clamp(particlePosition.x, bounds.x + particleSize.x, bounds.z - particleSize.x),
                                clamp(particlePosition.y, bounds.y + particleSize.y, bounds.w - particleSize.y));
    
    // Check collisions with the boundaries
    if (particlePosition.x < (bounds.x + particleSize.x) || particlePosition.x > (bounds.z - particleSize.x))
    {
        // Invert X velocity
        Particles[particleId].velocity = float2(particleVelocity.x * -1 * collisionDamping, particleVelocity.y);

    }

    if (particlePosition.y < (bounds.y + particleSize.y) || particlePosition.y > (bounds.w - particleSize.y))
    {
        // Invert Y velocity
        Particles[particleId].velocity = float2(particleVelocity.x, particleVelocity.y * -1 * collisionDamping);
    }

    
}

