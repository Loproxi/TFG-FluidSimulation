// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateNextPositions
#pragma kernel UpdateSpatialHashingInfo
#pragma kernel SortSpatialHashingInfo
#pragma kernel UpdateSpatialHashingIndices
#pragma kernel ComputeDensity
#pragma kernel ComputePressure
#pragma kernel ComputeViscosity
#pragma kernel ApplyForcesAndCollisions

//Include Functions From another hlsl
//#include "FluidComputeTools.hlsl" // WHY THS BREAKS

struct FluidParticleData
{
    float2 position; // 8
    float2 nextPosition; // 8
    float2 velocity; // 8
    float mass; // 4
    float density; // 4
    float nearDensity; // 4
};

static const int numOfThreads = 64;
static const uint MAX_UINT_VALUE = 4294967295;

//Buffer that will come back
RWStructuredBuffer<FluidParticleData> Particles;
RWStructuredBuffer<uint2> SpatialHashingInfo; // Vector x = particleIndex Vector Y = cellkey
RWStructuredBuffer<uint> SpatialHashingIndices;

float smoothingDensityRadius;
float collisionDamping;
float gasConstant;
float restDensity;
float gravity;
float deltaTime;
int numOfParticles;

//EACH WORK GROUP HAS 64 THREADS INSIDE OF IT
[numthreads(numOfThreads, 1, 1)]
void UpdateNextPositions(uint3 id : SV_DispatchThreadID)
{  
    //Create a deltaTime to predict
    float predictionDeltaTime = 1 / 120.0f;
    
    Particles[id.x].velocity += float2(0, gravity * deltaTime);
    //Predict where the particle is going to be on the next frame
    Particles[id.x].nextPosition = Particles[id.x].position + Particles[id.x].velocity * predictionDeltaTime;

}

[numthreads(numOfThreads, 1, 1)]
void UpdateSpatialHashingInfo(uint3 id : SV_DispatchThreadID)
{
    
    uint particleId = id.x;
    //Restart All indices by setting all of them to the Max UINT value
    SpatialHashingIndices[particleId].x = MAX_UINT_VALUE;
    
    //float2 cell = GetCellFromPosition(Particles[particleId].position, smoothingDensityRadius);
    //uint key = GetKeyFromHashedCell(HashingCell(cell),numOfParticles);

    //Update the Info on the spatial hashing
    //SpatialHashingInfo[particleId] = uint2((uint) particleId, key);

}

[numthreads(1, 1, 1)]
void SortSpatialHashingInfo(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    
    //for (int i = 0; i<)

    SpatialHashingInfo[id.x].x = 0.0f;
}

[numthreads(numOfThreads, 1, 1)]
void UpdateSpatialHashingIndices(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    SpatialHashingIndices[id.x].x = 0.0f;
}

[numthreads(numOfThreads, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Particles[id.x].density = 0.0f;
    Particles[id.x].nearDensity = 0.0f;
}

[numthreads(numOfThreads, 1, 1)]
void ComputePressure(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Particles[id.x].density = 0.0f;
}

[numthreads(numOfThreads, 1, 1)]
void ComputeViscosity(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Particles[id.x].density = 0.0f;
}

[numthreads(numOfThreads, 1, 1)]
void ApplyForcesAndCollisions(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Particles[id.x].density = 0.0f;
}
